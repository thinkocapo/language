


NOUN
        // nom,
        // akk. akk.pl - def?indef? NO
        // dat, dat.pl - in/vor/auf NO. just the ending.
        // construct (yes) or store (not yet) the case ending...

// pub struct Pronoun(p, g); // gender needs match gender of the nount
// pronoun calls p.calls(n) a noun, maybe a Word<T> orchestrates this.
// save accusative to the file? prob not, if using .dict's.
// generic Word<T> where T is Noun, Verb, Pronoun
// WORD (and SENTENCE is a linked-list of WORD's)


    // TODO pronoun, or Word and start building sentance.
    // ich du er/es/sie wir ihr sie/Sie
    // pub struct Pronoun{
    //     _1: String, _2: String, _3: String, _4: String, _5:String, _6:String
    // }
    // let pr = Pronoun{
    //     _1:"ich".to_string(), _2: "du".to_string(), _3: "er/es/sie".to_string(), 
    //     _4:"wir".to_string(), _5:"ihr".to_string(), _6: "sie/Sie".to_string()
    // };
    // println!("pronoun is {}", pr._2);


// I think the Verb decides if it's acc or dat n. Decides which personal pronoun...
        // so now thinking these aren't needed...
        // fn acc(&self) -> String {
        //     // need def/indef article? <--NO, hold-off.
        //     // m -> "den " + self.s
        //     // f -> "die " + self.s
        //     // n -> "die" + self.s
        //     // p -> 
        //     // return true|false
        // }
        // fn dat(&self) -> String {
        //     // return false, if can't be used in a realistic Dat use case
        // }

        // set the nom, acc, dat String<def_art, indef_art,
        // fn new(&self) -> Noun {
        //     s,p,g
        //     match gender -> acc: "den", f: "die", n: "die" // Pronoun<>{}? den, der, dem,
        // }

        // UPDATE - don't think I need acc, gender matching, setting articles...that's for the user to come up with.
        // UPDATE - could suggest a random Personal Pronoun / def/indef article, but don't Nom/Acc/Dat assume it



// .dict doesn't have metadata like 'case to use this verb with' nor 'popularity' of the word,
// but currently my intent is still to assign this in the line&space-separated files of words.



impl<T> AnyExt for T {
    fn type_name(&self) -> &'static str {
        std::any::type_name::<T>()
    }
}


#[derive(Debug)]
    enum Pronoun {
        Ich(String),
        Du(String),
        Wir(String),
        Ihr(String),
        Sie(String) 
    }
    let pr: Pronoun = match pronoun_pick {
        "Ich" => Pronoun::Ich(String::from("Ich")),
        "Du" => Pronoun::Du(String::from("Du")),
        "Wir" => Pronoun::Wir(String::from("Wir")),
        "Ihr" => Pronoun::Ihr(String::from("Ihr")),
        "Sie" => Pronoun::Sie(String::from("Sie")),
        _ => unreachable!(),
    };

    let mut pronoun: String = "".to_string();
    let thing = match pr {
        Pronoun::Ich(value) => pronoun = value,
        Pronoun::Du(value) => pronoun = value,
        Pronoun::Wir(value) => pronoun = value,
        Pronoun::Ihr(value) => pronoun = value,
        Pronoun::Sie(value) => pronoun = value,
        _ => println!("Something else"),
    };



// struct Word<T> {
//     class : T
//     // value, data, next: Word
// }
// impl<T> Word<T> {
    // pub fn new(class: T) -> Self {
    //     Word { class }
    // }
    // pub fn next() -> Self {}
// }


// Immutable and no methods needed yet.
// Maybe struct ones Word is evaluated for matching.
// pub struct Pronoun;



anfangenende anfangenenden m
schwiegermutter schwiegermUtter...
schwiegerfater schwiegerfater...

fleiSig gefleiSig


mehr als - more thread_rng

I like not having the answer in-program, forces you to take a brief pause, breadth, not overstimulate. Pay the price for not knowing it. Just look it up, learn it.

noun() or even 'word()' could decide which to apply, and print...?


struct Word<T> {
        class : T
        // value, data, next: Word
    }
    impl<T> Word<T> {
        pub fn new(class: T) -> Self {
            Word { class }
        }
        pub fn next() -> Self {}
    }
    
    let word = Word::new(Noun{s:"verkehr".to_string(), p:"verkehr".to_string(), g:"m".to_string()});
    let word1 = Word::new(noun);
    println!("word1 is: {:?}", word1.class);
    let word2 = Word::new(pronoun);
    println!("word2 is: {:?}", word2.class);
    let word3 = Word::new(verb);
    println!("word3 is: {:?}", word3.class);
